name: Test Redis Unstable CE Package

on:
  workflow_call:
    inputs:
      artifact_name:
        description: 'Name of the Redis artifact to download for test'
        required: true
        type: string
      runner:
        description: 'OS version to run tests on'
        required: true
        type: string

jobs:
  test:
    name: Test Redis CE
    runs-on: ${{ inputs.runner }}
    steps:
      - uses: actions/checkout@v4
        with:
          # Use unstable branch when called via workflow_call (from nightly scheduler)
          # Use current branch when triggered by PR (for testing)
          ref: ${{ github.event_name == 'workflow_call' && 'unstable' || github.ref }}

      - name: Download built package
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}

      - name: Install runtime dependencies
        run: |
          # Extract runtime dependencies from cask file
          DEPS=$(grep 'depends_on formula:' Casks/redis.rb | sed 's/.*depends_on formula: "\([^"]*\)".*/\1/' | tr '\n' ' ')
          echo "Installing runtime dependencies from cask file: $DEPS"
          brew install $DEPS

      - name: Setup local cask for testing
        run: |
          # Create temporary cask file that points to local artifact
          ARTIFACT_FILE=$(ls unsigned-redis-ce-unstable-*.zip)
          ARTIFACT_PATH="file://$(pwd)/$ARTIFACT_FILE"
          
          # Modify existing cask to point to local artifact
          sed -i "" "s|https://packages.redis.io/homebrew/redis-ce-.*\.zip|$ARTIFACT_PATH|g" Casks/redis.rb
          
          # Remove sha256 validation since we're using local file
          sed -i "" '/sha256 arm:/d' Casks/redis.rb
          sed -i "" '/intel:/d' Casks/redis.rb
          
          # Add current directory as tap
          brew tap redis/redis-unstable .

      - name: Install Redis CE via cask
        run: |
          brew install --cask redis/redis-unstable/redis --debug --verbose
          ls -al $(brew --prefix)/etc/redis.conf
          ls -al $(brew --prefix)/lib/redis/modules
          ls -al $(brew --prefix)/bin/redis*

      - name: Test Redis Installation
        run: |
          redis-server --version
          redis-server $(brew --prefix)/etc/redis.conf &
          for i in {1..30}; do redis-cli ping && break || echo "Waiting for Redis... $i" && sleep 1; done
          redis-cli info server || { echo "Cannot get server info"; exit 1; }
          redis-cli module list

      - name: Upload Redis logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: redis-logs-${{ inputs.runner }}
          path: /tmp/redis-logs/

      - name: Verify Installed Modules
        run: |
          modules=$(redis-cli module list)
          echo "Installed modules:"
          echo "$modules"
          missing_modules=()
          for module in "bf" "search" "timeseries" "ReJSON"; do
            if ! echo "$modules" | grep -q "$module"; then
              missing_modules+=("$module")
            fi
          done
          if [ ${#missing_modules[@]} -eq 0 ]; then
            echo "All required modules are installed"
          else
            echo "The following modules are missing: ${missing_modules[*]}"
            exit 1
          fi

      - name: Test RedisBloom
        run: |
          redis-cli BF.ADD popular_keys "redis:hash"
          redis-cli BF.ADD popular_keys "redis:set"
          [ "$(redis-cli BF.EXISTS popular_keys "redis:hash")" = "1" ] || \
            { echo "RedisBloom test failed: 'redis:hash' not found"; exit 1; }
          [ "$(redis-cli BF.EXISTS popular_keys "redis:list")" = "0" ] || \
            { echo "RedisBloom test failed: 'redis:list' found unexpectedly"; exit 1; }
          echo "RedisBloom test passed successfully"

      - name: Test RediSearch
        run: |
          redis-cli FT.CREATE redis_commands ON HASH PREFIX 1 cmd: SCHEMA name TEXT SORTABLE description TEXT
          redis-cli HSET cmd:set name "SET" description "Set the string value of a key"
          redis-cli HSET cmd:get name "GET" description "Get the value of a key"
          result=$(redis-cli FT.SEARCH redis_commands "value")
          if echo "$result" | grep -q "Set the string value of a key" && \
              echo "$result" | grep -q "Get the value of a key"; then
            echo "RediSearch test passed successfully"
          else
            echo "RediSearch test failed: expected commands not found in search results"
            exit 1
          fi

      - name: Test RedisTimeSeries
        run: |
          redis-cli TS.CREATE redis:cpu:usage RETENTION 86400
          redis-cli TS.ADD redis:cpu:usage "*" 80
          redis-cli TS.ADD redis:cpu:usage "*" 65
          redis-cli TS.ADD redis:cpu:usage "*" 70
          result=$(redis-cli TS.RANGE redis:cpu:usage - + COUNT 3)
          if echo "$result" | grep -q "80" && \
              echo "$result" | grep -q "65" && \
              echo "$result" | grep -q "70"; then
            echo "RedisTimeSeries test passed successfully"
          else
            echo "RedisTimeSeries test failed: expected values not found in time series"
            exit 1
          fi

      - name: Test ReJSON
        run: |
          redis-cli JSON.SET redis:config $ '{"maxmemory":"2gb","maxmemory-policy":"allkeys-lru"}'
          result=$(redis-cli JSON.GET redis:config $.maxmemory-policy)
          cleaned_result=$(echo $result | tr -d '[]"')
          if [ "$cleaned_result" = "allkeys-lru" ]; then
            echo "ReJSON test passed successfully"
          else
            echo "ReJSON test failed: expected 'allkeys-lru', got $result"
            exit 1
          fi

      - name: Cleanup
        if: always()
        run: |
          redis-cli shutdown || true
